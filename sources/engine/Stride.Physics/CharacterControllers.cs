using System;
using System.Diagnostics;
using System.Numerics;
using System.Runtime.CompilerServices;
using System.Threading;

using BepuPhysics;
using BepuPhysics.Collidables;
using BepuPhysics.CollisionDetection;
using BepuUtilities;
using BepuUtilities.Collections;
using BepuUtilities.Memory;
using BepuPhysics.Constraints;
using static BepuUtilities.GatherScatter;

namespace Stride.Physics
{
    public struct CharacterMotionAccumulatedImpulse
    {
        public Vector2Wide Horizontal;
        public Vector<float> Vertical;
    }

    //IMPORTANT NOTE: The static and dynamic motion constraint variants were autogenerated from a text template. To modify the constraint, modify the text template instead.
    //Using code generators to generate these sorts of constraint variants can work around some of the limitations in compile time expressiveness-
    //here, we avoid creating a bunch of duplicate math for the one and two body constraint cases which would have to be separately maintained.
    //There are other cases where this is pushed even further. Within the engine, the dozens of contact constraint variants are generated by text templates.
    //This isn't the most wonderful solution in terms of development experience or tooling, 
    //but it maximizes performance and avoids the need for in-language turing complete metaprogramming, so I'm okay with it.

    //Constraint descriptions provide an explicit mapping from the array-of-structures format to the internal array-of-structures-of-arrays format used by the solver.
    //Note that there is a separate description for the one and two body case- constraint implementations take advantage of the lack of a second body to reduce data gathering requirements.
    /// <summary>
    /// Description of a character motion constraint where the support is static.
    /// </summary>
    public struct StaticCharacterMotionConstraint : IOneBodyConstraintDescription<StaticCharacterMotionConstraint>
    {
        /// <summary>
        /// Maximum force that the horizontal motion constraint can apply to reach the current velocity goal.
        /// </summary>
        public float MaximumHorizontalForce;
        /// <summary>
        /// Maximum force that the vertical motion constraint can apply to fight separation.
        /// </summary>
        public float MaximumVerticalForce;
        /// <summary>
        /// Target horizontal velocity in terms of the basis X and -Z axes.
        /// </summary>
        public Vector2 TargetVelocity;
        /// <summary>
        /// Depth of the supporting contact. The vertical motion constraint permits separating velocity if, after a frame, the objects will still be touching.
        /// </summary>
		public float Depth;
        /// <summary>
        /// Stores the quaternion-packed orthonormal basis for the motion constraint. When expanded into a matrix, X and Z will represent the Right and Backward directions respectively. Y will represent Up.
        /// In other words, a target tangential velocity of (4, 2) will result in a goal velocity of 4 along the (1, 0, 0) * Basis direction and a goal velocity of 2 along the (0, 0, -1) * Basis direction.
        /// All motion moving along the (0, 1, 0) * Basis axis will be fought against by the vertical motion constraint.
        /// </summary>
        public Quaternion SurfaceBasis;
        /// <summary>
        /// World space offset from the character's center to apply impulses at.
        /// </summary>
        public Vector3 OffsetFromCharacterToSupportPoint;

        //It's possible to create multiple descriptions for the same underlying constraint type id which can update different parts of the constraint data.
        //This functionality isn't used very often, though- you'll notice that the engine has a 1:1 mapping (at least at the time of this writing).
        //But in principle, it doesn't have to be that way. So, the description must provide information about the type and type id.
        /// <summary>
        /// Gets the constraint type id that this description is associated with. 
        /// </summary>
        public int ConstraintTypeId => StaticCharacterMotionTypeProcessor.BatchTypeId;

        /// <summary>
        /// Gets the TypeProcessor type that is associated with this description.
        /// </summary>
        public Type TypeProcessorType => typeof(StaticCharacterMotionTypeProcessor);

        //Note that these mapping functions use a "GetOffsetInstance" function. Each CharacterMotionPrestep is a bundle of multiple constraints;
        //by grabbing an offset instance, we're selecting a specific slot in the bundle to modify. For simplicity and to guarantee consistency of field strides,
        //we refer to that slot using the same struct and then write only to the first slot.
        //(Note that accessing slots after the first may result in access violations; the 'offset instance' is not guaranteed to refer to valid data beyond the first slot!)
        public void ApplyDescription(ref TypeBatch batch, int bundleIndex, int innerIndex)
        {
            ref var target = ref GetOffsetInstance(ref Buffer<StaticCharacterMotionPrestep>.Get(ref batch.PrestepData, bundleIndex), innerIndex);
            QuaternionWide.WriteFirst(SurfaceBasis, ref target.SurfaceBasis);
            GetFirst(ref target.MaximumHorizontalForce) = MaximumHorizontalForce;
            GetFirst(ref target.MaximumVerticalForce) = MaximumVerticalForce;
            Vector2Wide.WriteFirst(TargetVelocity, ref target.TargetVelocity);
            GetFirst(ref target.Depth) = Depth;
            Vector3Wide.WriteFirst(OffsetFromCharacterToSupportPoint, ref target.OffsetFromCharacter);
        }

        public void BuildDescription(ref TypeBatch batch, int bundleIndex, int innerIndex, out StaticCharacterMotionConstraint description)
        {
            ref var source = ref GetOffsetInstance(ref Buffer<StaticCharacterMotionPrestep>.Get(ref batch.PrestepData, bundleIndex), innerIndex);
            QuaternionWide.ReadFirst(source.SurfaceBasis, out description.SurfaceBasis);
            description.MaximumHorizontalForce = GetFirst(ref source.MaximumHorizontalForce);
            description.MaximumVerticalForce = GetFirst(ref source.MaximumVerticalForce);
            Vector2Wide.ReadFirst(source.TargetVelocity, out description.TargetVelocity);
            description.Depth = GetFirst(ref source.Depth);
            Vector3Wide.ReadFirst(source.OffsetFromCharacter, out description.OffsetFromCharacterToSupportPoint);
        }
    }

    //Note that all the solver-side data is in terms of 'Wide' data types- the solver never works on just one constraint at a time. Instead,
    //it executes them in bundles of width equal to the runtime/hardware exposed SIMD unit width. This lets the solver scale with wider compute units.
    //(This is important for machines that can perform 8 or more operations per instruction- there's no good way to map a single constraint instance's 
    //computation onto such a wide instruction, so if the solver tried to do such a thing, it would leave a huge amount of performance on the table.)

    //"Prestep" data can be thought of as the input to the solver. It describes everything the solver needs to know about.
    /// <summary>
    /// AOSOA formatted bundle of prestep data for multiple static-supported character motion constraints.
    /// </summary>
    public struct StaticCharacterMotionPrestep
    {
        //Note that the prestep data layout is important. The solver tends to be severely memory bandwidth bound, so using a minimal representation is valuable.
        //That's why the Basis is stored as a quaternion and not a full Matrix- the cost of the arithmetic operations to expand it back into the original matrix form is far less
        //than the cost of loading all the extra lanes of data when scaled up to many cores.
        public QuaternionWide SurfaceBasis;
        public Vector<float> MaximumHorizontalForce;
        public Vector<float> MaximumVerticalForce;
        public Vector<float> Depth;
        public Vector2Wide TargetVelocity;
        public Vector3Wide OffsetFromCharacter;
    }

    //Using the prestep data plus some current body state, the solver computes the information required to execute velocity iterations. The main purpose of this intermediate data
    //is to describe the projection from body velocities into constraint space impulses, and from constraint space impulses to body velocities again.
    public struct StaticCharacterMotionProjection
    {
        public QuaternionWide SurfaceBasis;
        public Vector3Wide OffsetFromCharacter;
        public Vector2Wide TargetVelocity;
        public Symmetric2x2Wide HorizontalEffectiveMass;
        public Vector<float> MaximumHorizontalImpulse;
        public BodyInertias InertiaA;
        public Vector<float> VerticalBiasVelocity;
        public Vector<float> VerticalEffectiveMass;
        public Vector<float> MaximumVerticalForce;

    }

    public struct StaticCharacterMotionFunctions : IOneBodyConstraintFunctions<StaticCharacterMotionPrestep, StaticCharacterMotionProjection, CharacterMotionAccumulatedImpulse>
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        static void ComputeJacobians(in Vector3Wide offsetA, in QuaternionWide basisQuaternion,
            out Matrix3x3Wide basis,
            out Matrix2x3Wide horizontalAngularJacobianA,
            out Vector3Wide verticalAngularJacobianA)
        {
            //Both of the motion constraints are velocity motors, like tangent friction. They don't actually have a position level goal.
            //But if we did want to make such a position level goal, it could be expressed as:
            //dot(basis.X, constrainedPointOnA - constrainedPointOnB) = 0
            //dot(basis.Y, constrainedPointOnA - constrainedPointOnB) <= 0 
            //dot(basis.Z, constrainedPointOnA - constrainedPointOnB) = 0
            //Note that the Y axis, corresponding to the vertical motion constraint, is an inequality. It pulls toward the surface, but never pushes away.
            //It also has a separate maximum force and acts on an independent axis; that's why we solve it as a separate constraint.
            //To get a velocity constraint out of these position goals, differentiate with respect to time:
            //d/dt(dot(basis.X, constrainedPointOnA - constrainedPointOnB)) = dot(basis.X, d/dt(constrainedPointOnA - constrainedPointOnB))
            //                                                              = dot(basis.X, a.LinearVelocity + a.AngularVelocity x offsetToConstrainedPointOnA - b.linearVelocity - b.AngularVelocity x offsetToConstrainedPointOnB)
            //Throwing some algebra and identities at it:
            //dot(basis.X, a.LinearVelocity) + dot(basis.X, a.AngularVelocity x offsetToConstrainedPointOnA) + dot(-basis.X, b.LinearVelocity) + dot(basis.X, offsetToConstrainedPointOnB x b.AngularVelocity)
            //dot(basis.X, a.LinearVelocity) + dot(a.AngularVelocity, offsetToConstrainedPointOnA x basis.X) + dot(-basis.X, b.LinearVelocity) + dot(b.AngularVelocity, basis.X x offsetToConstrainedPointOnB)
            //The (transpose) jacobian is the transform that pulls the body velocity into constraint space- 
            //and here, we can see that we have an axis being dotted with each component of the velocity. That's gives us the jacobian for that degree of freedom.
            //The same form applies to all three axes of the basis, since they're all doing the same thing (just on different directions and with different force bounds).
            //Note that we don't explicitly output linear jacobians- they are just the axes of the basis, and the linear jacobians of B are just the negated linear jacobians of A.
            Matrix3x3Wide.CreateFromQuaternion(basisQuaternion, out basis);
            Vector3Wide.CrossWithoutOverlap(offsetA, basis.X, out horizontalAngularJacobianA.X);
            Vector3Wide.CrossWithoutOverlap(offsetA, basis.Y, out verticalAngularJacobianA);
            Vector3Wide.CrossWithoutOverlap(offsetA, basis.Z, out horizontalAngularJacobianA.Y);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Prestep(Bodies bodies, ref Vector<int> bodyReferences, int count, float dt, float inverseDt, ref BodyInertias inertiaA, ref StaticCharacterMotionPrestep prestepData, out StaticCharacterMotionProjection projection)
        {
            //The motion constraint is split into two parts: the horizontal constraint, and the vertical constraint.
            //The horizontal constraint acts almost exactly like the TangentFriction, but we'll duplicate some of the logic to keep this implementation self-contained.
            ComputeJacobians(prestepData.OffsetFromCharacter, prestepData.SurfaceBasis,
                out var basis, out var horizontalAngularJacobianA, out var verticalAngularJacobianA);

            //I'll omit the details of where this comes from, but you can check out the other constraints or the sorta-tutorial Inequality1DOF constraint to explain the details,
            //plus some other references. The idea is that we need a way to transform the constraint space velocity (that we get from transforming body velocities
            //by the transpose jacobian) into a corrective impulse for the solver iterations. That corrective impulse is then used to update the velocities on each iteration execution.
            //This transform is the 'effective mass', representing the mass felt by the constraint in its local space.
            //In concept, this constraint is actually two separate constraints solved iteratively, so we have two separate such effective mass transforms.
            Symmetric3x3Wide.MatrixSandwich(horizontalAngularJacobianA, inertiaA.InverseInertiaTensor, out var inverseHorizontalEffectiveMass);
            //The linear jacobians are unit length vectors, so J * M^-1 * JT is just M^-1.
            inverseHorizontalEffectiveMass.XX += inertiaA.InverseMass;
            inverseHorizontalEffectiveMass.YY += inertiaA.InverseMass;
            Symmetric2x2Wide.InvertWithoutOverlap(inverseHorizontalEffectiveMass, out projection.HorizontalEffectiveMass);

            //Note that many characters will just have zero inverse inertia tensors to prevent them from rotating, so this could be optimized.
            //(Removing a transform wouldn't matter, but avoiding the storage of an inertia tensor in the projection would be useful.)
            //We don't take advantage of this optimization for simplicity, and so that you could use this constraint unchanged in a simulation
            //where the orientation is instead controlled by some other constraint or torque- imagine a game with gravity that points in different directions.
            Symmetric3x3Wide.VectorSandwich(verticalAngularJacobianA, inertiaA.InverseInertiaTensor, out var verticalAngularContributionA);
            var inverseVerticalEffectiveMass = verticalAngularContributionA + inertiaA.InverseMass;
            projection.VerticalEffectiveMass = Vector<float>.One / inverseVerticalEffectiveMass;

            //Note that we still use the packed representation in the projection information, even though we unpacked it in the prestep.
            //The solver iterations will redo that math rather than storing the full jacobians. This saves quite a bit of memory bandwidth.
            //Storing every jacobian (except duplicate linear jacobians) would require 2x3 * 3 + 1x3 * 3 = 27 wide scalars, 
            //while storing the quaternion basis and two offsets requires only 4 + 3 + 3 = 10 scalars.

            //(That might sound irrelevant, but on an AVX2 system, 17 extra scalars means 544 extra bytes per solve iteration.
            //If a machine has 40GBps of main memory bandwidth, those extra bytes require ~13.5 nanoseconds. 
            //A quad core AVX2 processor could easily perform over 300 instructions in that time. The story only gets more bandwidth-limited
            //as the core count scales up on pretty much all modern processors.)

            //If you're wondering why we're just copying all of this into the projection rather than loading it again from the prestep data and body data,
            //it's (once again) to minimize memory bandwidth and cache misses. By copying it all into one contiguous struct, the solver iterations
            //have effectively optimal cache line efficiency (outside of their body velocity gathers and scatters, but that's unavoidable in this solver type).
            projection.SurfaceBasis = prestepData.SurfaceBasis;
            projection.OffsetFromCharacter = prestepData.OffsetFromCharacter;

            projection.TargetVelocity.X = prestepData.TargetVelocity.X;
            //The surface basis's Z axis points in the opposite direction to the view direction, so negate the target velocity along the Z axis to point it in the expected direction.
            projection.TargetVelocity.Y = -prestepData.TargetVelocity.Y;
            projection.InertiaA = inertiaA;
            projection.MaximumHorizontalImpulse = prestepData.MaximumHorizontalForce * dt;
            projection.MaximumVerticalForce = prestepData.MaximumVerticalForce * dt;
            //If the character is deeply penetrating, the vertical motion constraint will allow some separating velocity- just enough for one frame of integration to reach zero depth.
            projection.VerticalBiasVelocity = Vector.Max(Vector<float>.Zero, prestepData.Depth * inverseDt);

            //Note that there are other ways to store constraints efficiently, some of which can actually reduce the amount of compute work required by the solver iterations.
            //Their use depends on the number of DOFs in the constraint and sometimes special properties of specific constraints.
            //For more details, take a look at the Inequality1DOF sample constraint.
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static void ApplyHorizontalImpulse(in Matrix3x3Wide basis,
            in Matrix2x3Wide angularJacobianA, in Vector2Wide constraintSpaceImpulse,
            in BodyInertias inertiaA,
            ref BodyVelocities velocityA)
        {
            //Transform the constraint space impulse into world space by using the jacobian and then apply each body's inverse inertia to get the velocity change.
            Vector3Wide.Scale(basis.X, constraintSpaceImpulse.X, out var linearImpulseAX);
            Vector3Wide.Scale(basis.Z, constraintSpaceImpulse.Y, out var linearImpulseAY);
            Vector3Wide.Add(linearImpulseAX, linearImpulseAY, out var linearImpulseA);
            Vector3Wide.Scale(linearImpulseA, inertiaA.InverseMass, out var linearChangeA);
            Vector3Wide.Add(velocityA.Linear, linearChangeA, out velocityA.Linear);

            Matrix2x3Wide.Transform(constraintSpaceImpulse, angularJacobianA, out var angularImpulseA);
            Symmetric3x3Wide.TransformWithoutOverlap(angularImpulseA, inertiaA.InverseInertiaTensor, out var angularChangeA);
            Vector3Wide.Add(velocityA.Angular, angularChangeA, out velocityA.Angular);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static void ApplyVerticalImpulse(in Matrix3x3Wide basis,
            in Vector3Wide angularJacobianA, in Vector<float> constraintSpaceImpulse,
            in BodyInertias inertiaA,
            ref BodyVelocities velocityA)
        {
            Vector3Wide.Scale(basis.Y, constraintSpaceImpulse, out var linearImpulseA);
            Vector3Wide.Scale(linearImpulseA, inertiaA.InverseMass, out var linearChangeA);
            Vector3Wide.Add(velocityA.Linear, linearChangeA, out velocityA.Linear);

            Vector3Wide.Scale(angularJacobianA, constraintSpaceImpulse, out var angularImpulseA);
            Symmetric3x3Wide.TransformWithoutOverlap(angularImpulseA, inertiaA.InverseInertiaTensor, out var angularChangeA);
            Vector3Wide.Add(velocityA.Angular, angularChangeA, out velocityA.Angular);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WarmStart(ref BodyVelocities velocityA, ref StaticCharacterMotionProjection projection, ref CharacterMotionAccumulatedImpulse accumulatedImpulse)
        {
            ComputeJacobians(projection.OffsetFromCharacter, projection.SurfaceBasis,
                out var basis, out var horizontalAngularJacobianA, out var verticalAngularJacobianA);
            ApplyHorizontalImpulse(basis, horizontalAngularJacobianA, accumulatedImpulse.Horizontal, projection.InertiaA, ref velocityA);
            ApplyVerticalImpulse(basis, verticalAngularJacobianA, accumulatedImpulse.Vertical, projection.InertiaA, ref velocityA);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Solve(ref BodyVelocities velocityA, ref StaticCharacterMotionProjection projection, ref CharacterMotionAccumulatedImpulse accumulatedImpulse)
        {
            ComputeJacobians(projection.OffsetFromCharacter, projection.SurfaceBasis,
                out var basis, out var horizontalAngularJacobianA, out var verticalAngularJacobianA);

            //Compute the velocity error by projecting the body velocity into constraint space using the transposed jacobian.
            Vector2Wide horizontalLinearA;
            Vector3Wide.Dot(basis.X, velocityA.Linear, out horizontalLinearA.X);
            Vector3Wide.Dot(basis.Z, velocityA.Linear, out horizontalLinearA.Y);
            Matrix2x3Wide.TransformByTransposeWithoutOverlap(velocityA.Angular, horizontalAngularJacobianA, out var horizontalAngularA);
            Vector2Wide.Add(horizontalLinearA, horizontalAngularA, out var horizontalVelocity);

            Vector2Wide.Subtract(projection.TargetVelocity, horizontalVelocity, out var horizontalConstraintSpaceVelocityChange);
            Symmetric2x2Wide.TransformWithoutOverlap(horizontalConstraintSpaceVelocityChange, projection.HorizontalEffectiveMass, out var horizontalCorrectiveImpulse);

            //Limit the force applied by the horizontal motion constraint. Note that this clamps the *accumulated* impulse applied this time step, not just this one iterations' value.
            var previousHorizontalAccumulatedImpulse = accumulatedImpulse.Horizontal;
            Vector2Wide.Add(accumulatedImpulse.Horizontal, horizontalCorrectiveImpulse, out accumulatedImpulse.Horizontal);
            Vector2Wide.Length(accumulatedImpulse.Horizontal, out var horizontalImpulseMagnitude);
            //Note division by zero guard.
            var scale = Vector.Min(Vector<float>.One, projection.MaximumHorizontalImpulse / Vector.Max(new Vector<float>(1e-16f), horizontalImpulseMagnitude));
            Vector2Wide.Scale(accumulatedImpulse.Horizontal, scale, out accumulatedImpulse.Horizontal);
            Vector2Wide.Subtract(accumulatedImpulse.Horizontal, previousHorizontalAccumulatedImpulse, out horizontalCorrectiveImpulse);

            ApplyHorizontalImpulse(basis, horizontalAngularJacobianA, horizontalCorrectiveImpulse, projection.InertiaA, ref velocityA);

            //Same thing for the vertical constraint.
            Vector3Wide.Dot(basis.Y, velocityA.Linear, out var verticalLinearA);
            Vector3Wide.Dot(velocityA.Angular, verticalAngularJacobianA, out var verticalAngularA);
            //The vertical constraint just targets zero velocity, but does not attempt to fight any velocity which would merely push the character out of penetration.
            var verticalCorrectiveImpulse = (projection.VerticalBiasVelocity - verticalLinearA - verticalAngularA) * projection.VerticalEffectiveMass;

            //Clamp the vertical constraint's impulse, but note that this is a bit different than above- the vertical constraint is not allowed to *push*, so there's an extra bound at zero.
            var previousVerticalAccumulatedImpulse = accumulatedImpulse.Vertical;
            accumulatedImpulse.Vertical = Vector.Min(Vector<float>.Zero, Vector.Max(accumulatedImpulse.Vertical + verticalCorrectiveImpulse, -projection.MaximumVerticalForce));
            verticalCorrectiveImpulse = accumulatedImpulse.Vertical - previousVerticalAccumulatedImpulse;

            ApplyVerticalImpulse(basis, verticalAngularJacobianA, verticalCorrectiveImpulse, projection.InertiaA, ref velocityA);
        }

    }

    //Each constraint type has its own 'type processor'- it acts as the outer loop that handles all the common logic across batches of constraints and invokes
    //the per-constraint logic as needed. The CharacterMotionFunctions type provides the actual implementation.
    public class StaticCharacterMotionTypeProcessor : OneBodyTypeProcessor<StaticCharacterMotionPrestep, StaticCharacterMotionProjection, CharacterMotionAccumulatedImpulse, StaticCharacterMotionFunctions>
    {
        /// <summary>
        /// Simulation-wide unique id for the character motion constraint. Every type has needs a unique compile time id; this is a little bit annoying to guarantee given that there is no central
        /// registry of all types that can exist (custom ones, like this one, can always be created), but having it be constant helps simplify and optimize its internal usage.
        /// </summary>
        public const int BatchTypeId = 50;
    }
    //Constraint descriptions provide an explicit mapping from the array-of-structures format to the internal array-of-structures-of-arrays format used by the solver.
    //Note that there is a separate description for the one and two body case- constraint implementations take advantage of the lack of a second body to reduce data gathering requirements.
    /// <summary>
    /// Description of a character motion constraint where the support is dynamic.
    /// </summary>
    public struct DynamicCharacterMotionConstraint : ITwoBodyConstraintDescription<DynamicCharacterMotionConstraint>
    {
        /// <summary>
        /// Maximum force that the horizontal motion constraint can apply to reach the current velocity goal.
        /// </summary>
        public float MaximumHorizontalForce;
        /// <summary>
        /// Maximum force that the vertical motion constraint can apply to fight separation.
        /// </summary>
        public float MaximumVerticalForce;
        /// <summary>
        /// Target horizontal velocity in terms of the basis X and -Z axes.
        /// </summary>
        public Vector2 TargetVelocity;
        /// <summary>
        /// Depth of the supporting contact. The vertical motion constraint permits separating velocity if, after a frame, the objects will still be touching.
        /// </summary>
		public float Depth;
        /// <summary>
        /// Stores the quaternion-packed orthonormal basis for the motion constraint. When expanded into a matrix, X and Z will represent the Right and Backward directions respectively. Y will represent Up.
        /// In other words, a target tangential velocity of (4, 2) will result in a goal velocity of 4 along the (1, 0, 0) * Basis direction and a goal velocity of 2 along the (0, 0, -1) * Basis direction.
        /// All motion moving along the (0, 1, 0) * Basis axis will be fought against by the vertical motion constraint.
        /// </summary>
        public Quaternion SurfaceBasis;
        /// <summary>
        /// World space offset from the character's center to apply impulses at.
        /// </summary>
        public Vector3 OffsetFromCharacterToSupportPoint;
        /// <summary>
        /// World space offset from the support's center to apply impulses at.
        /// </summary>
        public Vector3 OffsetFromSupportToSupportPoint;

        //It's possible to create multiple descriptions for the same underlying constraint type id which can update different parts of the constraint data.
        //This functionality isn't used very often, though- you'll notice that the engine has a 1:1 mapping (at least at the time of this writing).
        //But in principle, it doesn't have to be that way. So, the description must provide information about the type and type id.
        /// <summary>
        /// Gets the constraint type id that this description is associated with. 
        /// </summary>
        public int ConstraintTypeId => DynamicCharacterMotionTypeProcessor.BatchTypeId;

        /// <summary>
        /// Gets the TypeProcessor type that is associated with this description.
        /// </summary>
        public Type TypeProcessorType => typeof(DynamicCharacterMotionTypeProcessor);

        //Note that these mapping functions use a "GetOffsetInstance" function. Each CharacterMotionPrestep is a bundle of multiple constraints;
        //by grabbing an offset instance, we're selecting a specific slot in the bundle to modify. For simplicity and to guarantee consistency of field strides,
        //we refer to that slot using the same struct and then write only to the first slot.
        //(Note that accessing slots after the first may result in access violations; the 'offset instance' is not guaranteed to refer to valid data beyond the first slot!)
        public void ApplyDescription(ref TypeBatch batch, int bundleIndex, int innerIndex)
        {
            ref var target = ref GetOffsetInstance(ref Buffer<DynamicCharacterMotionPrestep>.Get(ref batch.PrestepData, bundleIndex), innerIndex);
            QuaternionWide.WriteFirst(SurfaceBasis, ref target.SurfaceBasis);
            GetFirst(ref target.MaximumHorizontalForce) = MaximumHorizontalForce;
            GetFirst(ref target.MaximumVerticalForce) = MaximumVerticalForce;
            Vector2Wide.WriteFirst(TargetVelocity, ref target.TargetVelocity);
            GetFirst(ref target.Depth) = Depth;
            Vector3Wide.WriteFirst(OffsetFromCharacterToSupportPoint, ref target.OffsetFromCharacter);
            Vector3Wide.WriteFirst(OffsetFromSupportToSupportPoint, ref target.OffsetFromSupport);
        }

        public void BuildDescription(ref TypeBatch batch, int bundleIndex, int innerIndex, out DynamicCharacterMotionConstraint description)
        {
            ref var source = ref GetOffsetInstance(ref Buffer<DynamicCharacterMotionPrestep>.Get(ref batch.PrestepData, bundleIndex), innerIndex);
            QuaternionWide.ReadFirst(source.SurfaceBasis, out description.SurfaceBasis);
            description.MaximumHorizontalForce = GetFirst(ref source.MaximumHorizontalForce);
            description.MaximumVerticalForce = GetFirst(ref source.MaximumVerticalForce);
            Vector2Wide.ReadFirst(source.TargetVelocity, out description.TargetVelocity);
            description.Depth = GetFirst(ref source.Depth);
            Vector3Wide.ReadFirst(source.OffsetFromCharacter, out description.OffsetFromCharacterToSupportPoint);
            Vector3Wide.ReadFirst(source.OffsetFromSupport, out description.OffsetFromSupportToSupportPoint);
        }
    }

    //Note that all the solver-side data is in terms of 'Wide' data types- the solver never works on just one constraint at a time. Instead,
    //it executes them in bundles of width equal to the runtime/hardware exposed SIMD unit width. This lets the solver scale with wider compute units.
    //(This is important for machines that can perform 8 or more operations per instruction- there's no good way to map a single constraint instance's 
    //computation onto such a wide instruction, so if the solver tried to do such a thing, it would leave a huge amount of performance on the table.)

    //"Prestep" data can be thought of as the input to the solver. It describes everything the solver needs to know about.
    /// <summary>
    /// AOSOA formatted bundle of prestep data for multiple dynamic-supported character motion constraints.
    /// </summary>
    public struct DynamicCharacterMotionPrestep
    {
        //Note that the prestep data layout is important. The solver tends to be severely memory bandwidth bound, so using a minimal representation is valuable.
        //That's why the Basis is stored as a quaternion and not a full Matrix- the cost of the arithmetic operations to expand it back into the original matrix form is far less
        //than the cost of loading all the extra lanes of data when scaled up to many cores.
        public QuaternionWide SurfaceBasis;
        public Vector<float> MaximumHorizontalForce;
        public Vector<float> MaximumVerticalForce;
        public Vector<float> Depth;
        public Vector2Wide TargetVelocity;
        public Vector3Wide OffsetFromCharacter;
        public Vector3Wide OffsetFromSupport;
    }

    //Using the prestep data plus some current body state, the solver computes the information required to execute velocity iterations. The main purpose of this intermediate data
    //is to describe the projection from body velocities into constraint space impulses, and from constraint space impulses to body velocities again.
    public struct DynamicCharacterMotionProjection
    {
        public QuaternionWide SurfaceBasis;
        public Vector3Wide OffsetFromCharacter;
        public Vector3Wide OffsetFromSupport;
        public Vector2Wide TargetVelocity;
        public Symmetric2x2Wide HorizontalEffectiveMass;
        public Vector<float> MaximumHorizontalImpulse;
        public BodyInertias InertiaA;
        public BodyInertias InertiaB;
        public Vector<float> VerticalBiasVelocity;
        public Vector<float> VerticalEffectiveMass;
        public Vector<float> MaximumVerticalForce;

    }

    public struct DynamicCharacterMotionFunctions : IConstraintFunctions<DynamicCharacterMotionPrestep, DynamicCharacterMotionProjection, CharacterMotionAccumulatedImpulse>
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        static void ComputeJacobians(in Vector3Wide offsetA, in Vector3Wide offsetB, in QuaternionWide basisQuaternion,
            out Matrix3x3Wide basis,
            out Matrix2x3Wide horizontalAngularJacobianA, out Matrix2x3Wide horizontalAngularJacobianB,
            out Vector3Wide verticalAngularJacobianA, out Vector3Wide verticalAngularJacobianB)
        {
            //Both of the motion constraints are velocity motors, like tangent friction. They don't actually have a position level goal.
            //But if we did want to make such a position level goal, it could be expressed as:
            //dot(basis.X, constrainedPointOnA - constrainedPointOnB) = 0
            //dot(basis.Y, constrainedPointOnA - constrainedPointOnB) <= 0 
            //dot(basis.Z, constrainedPointOnA - constrainedPointOnB) = 0
            //Note that the Y axis, corresponding to the vertical motion constraint, is an inequality. It pulls toward the surface, but never pushes away.
            //It also has a separate maximum force and acts on an independent axis; that's why we solve it as a separate constraint.
            //To get a velocity constraint out of these position goals, differentiate with respect to time:
            //d/dt(dot(basis.X, constrainedPointOnA - constrainedPointOnB)) = dot(basis.X, d/dt(constrainedPointOnA - constrainedPointOnB))
            //                                                              = dot(basis.X, a.LinearVelocity + a.AngularVelocity x offsetToConstrainedPointOnA - b.linearVelocity - b.AngularVelocity x offsetToConstrainedPointOnB)
            //Throwing some algebra and identities at it:
            //dot(basis.X, a.LinearVelocity) + dot(basis.X, a.AngularVelocity x offsetToConstrainedPointOnA) + dot(-basis.X, b.LinearVelocity) + dot(basis.X, offsetToConstrainedPointOnB x b.AngularVelocity)
            //dot(basis.X, a.LinearVelocity) + dot(a.AngularVelocity, offsetToConstrainedPointOnA x basis.X) + dot(-basis.X, b.LinearVelocity) + dot(b.AngularVelocity, basis.X x offsetToConstrainedPointOnB)
            //The (transpose) jacobian is the transform that pulls the body velocity into constraint space- 
            //and here, we can see that we have an axis being dotted with each component of the velocity. That's gives us the jacobian for that degree of freedom.
            //The same form applies to all three axes of the basis, since they're all doing the same thing (just on different directions and with different force bounds).
            //Note that we don't explicitly output linear jacobians- they are just the axes of the basis, and the linear jacobians of B are just the negated linear jacobians of A.
            Matrix3x3Wide.CreateFromQuaternion(basisQuaternion, out basis);
            Vector3Wide.CrossWithoutOverlap(offsetA, basis.X, out horizontalAngularJacobianA.X);
            Vector3Wide.CrossWithoutOverlap(offsetA, basis.Y, out verticalAngularJacobianA);
            Vector3Wide.CrossWithoutOverlap(offsetA, basis.Z, out horizontalAngularJacobianA.Y);
            Vector3Wide.CrossWithoutOverlap(basis.X, offsetB, out horizontalAngularJacobianB.X);
            Vector3Wide.CrossWithoutOverlap(basis.Y, offsetB, out verticalAngularJacobianB);
            Vector3Wide.CrossWithoutOverlap(basis.Z, offsetB, out horizontalAngularJacobianB.Y);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Prestep(Bodies bodies, ref TwoBodyReferences bodyReferences, int count, float dt, float inverseDt, ref BodyInertias inertiaA, ref BodyInertias inertiaB, ref DynamicCharacterMotionPrestep prestepData, out DynamicCharacterMotionProjection projection)
        {
            //The motion constraint is split into two parts: the horizontal constraint, and the vertical constraint.
            //The horizontal constraint acts almost exactly like the TangentFriction, but we'll duplicate some of the logic to keep this implementation self-contained.
            ComputeJacobians(prestepData.OffsetFromCharacter, prestepData.OffsetFromSupport, prestepData.SurfaceBasis,
                out var basis, out var horizontalAngularJacobianA, out var horizontalAngularJacobianB, out var verticalAngularJacobianA, out var verticalAngularJacobianB);

            //I'll omit the details of where this comes from, but you can check out the other constraints or the sorta-tutorial Inequality1DOF constraint to explain the details,
            //plus some other references. The idea is that we need a way to transform the constraint space velocity (that we get from transforming body velocities
            //by the transpose jacobian) into a corrective impulse for the solver iterations. That corrective impulse is then used to update the velocities on each iteration execution.
            //This transform is the 'effective mass', representing the mass felt by the constraint in its local space.
            //In concept, this constraint is actually two separate constraints solved iteratively, so we have two separate such effective mass transforms.
            Symmetric3x3Wide.MatrixSandwich(horizontalAngularJacobianA, inertiaA.InverseInertiaTensor, out var horizontalAngularContributionA);
            Symmetric3x3Wide.MatrixSandwich(horizontalAngularJacobianB, inertiaB.InverseInertiaTensor, out var horizontalAngularContributionB);
            Symmetric2x2Wide.Add(horizontalAngularContributionA, horizontalAngularContributionB, out var inverseHorizontalEffectiveMass);
            //The linear jacobians are unit length vectors, so J * M^-1 * JT is just M^-1.
            var linearContribution = inertiaA.InverseMass + inertiaB.InverseMass;
            inverseHorizontalEffectiveMass.XX += linearContribution;
            inverseHorizontalEffectiveMass.YY += linearContribution;
            Symmetric2x2Wide.InvertWithoutOverlap(inverseHorizontalEffectiveMass, out projection.HorizontalEffectiveMass);

            //Note that many characters will just have zero inverse inertia tensors to prevent them from rotating, so this could be optimized.
            //(Removing a transform wouldn't matter, but avoiding the storage of an inertia tensor in the projection would be useful.)
            //We don't take advantage of this optimization for simplicity, and so that you could use this constraint unchanged in a simulation
            //where the orientation is instead controlled by some other constraint or torque- imagine a game with gravity that points in different directions.
            Symmetric3x3Wide.VectorSandwich(verticalAngularJacobianA, inertiaA.InverseInertiaTensor, out var verticalAngularContributionA);
            Symmetric3x3Wide.VectorSandwich(verticalAngularJacobianB, inertiaB.InverseInertiaTensor, out var verticalAngularContributionB);
            var inverseVerticalEffectiveMass = verticalAngularContributionA + verticalAngularContributionB + linearContribution;
            projection.VerticalEffectiveMass = Vector<float>.One / inverseVerticalEffectiveMass;

            //Note that we still use the packed representation in the projection information, even though we unpacked it in the prestep.
            //The solver iterations will redo that math rather than storing the full jacobians. This saves quite a bit of memory bandwidth.
            //Storing every jacobian (except duplicate linear jacobians) would require 2x3 * 3 + 1x3 * 3 = 27 wide scalars, 
            //while storing the quaternion basis and two offsets requires only 4 + 3 + 3 = 10 scalars.

            //(That might sound irrelevant, but on an AVX2 system, 17 extra scalars means 544 extra bytes per solve iteration.
            //If a machine has 40GBps of main memory bandwidth, those extra bytes require ~13.5 nanoseconds. 
            //A quad core AVX2 processor could easily perform over 300 instructions in that time. The story only gets more bandwidth-limited
            //as the core count scales up on pretty much all modern processors.)

            //If you're wondering why we're just copying all of this into the projection rather than loading it again from the prestep data and body data,
            //it's (once again) to minimize memory bandwidth and cache misses. By copying it all into one contiguous struct, the solver iterations
            //have effectively optimal cache line efficiency (outside of their body velocity gathers and scatters, but that's unavoidable in this solver type).
            projection.SurfaceBasis = prestepData.SurfaceBasis;
            projection.OffsetFromCharacter = prestepData.OffsetFromCharacter;
            projection.OffsetFromSupport = prestepData.OffsetFromSupport;

            projection.TargetVelocity.X = prestepData.TargetVelocity.X;
            //The surface basis's Z axis points in the opposite direction to the view direction, so negate the target velocity along the Z axis to point it in the expected direction.
            projection.TargetVelocity.Y = -prestepData.TargetVelocity.Y;
            projection.InertiaA = inertiaA;
            projection.InertiaB = inertiaB;
            projection.MaximumHorizontalImpulse = prestepData.MaximumHorizontalForce * dt;
            projection.MaximumVerticalForce = prestepData.MaximumVerticalForce * dt;
            //If the character is deeply penetrating, the vertical motion constraint will allow some separating velocity- just enough for one frame of integration to reach zero depth.
            projection.VerticalBiasVelocity = Vector.Max(Vector<float>.Zero, prestepData.Depth * inverseDt);

            //Note that there are other ways to store constraints efficiently, some of which can actually reduce the amount of compute work required by the solver iterations.
            //Their use depends on the number of DOFs in the constraint and sometimes special properties of specific constraints.
            //For more details, take a look at the Inequality1DOF sample constraint.
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static void ApplyHorizontalImpulse(in Matrix3x3Wide basis,
            in Matrix2x3Wide angularJacobianA, in Matrix2x3Wide angularJacobianB, in Vector2Wide constraintSpaceImpulse,
            in BodyInertias inertiaA, in BodyInertias inertiaB,
            ref BodyVelocities velocityA, ref BodyVelocities velocityB)
        {
            //Transform the constraint space impulse into world space by using the jacobian and then apply each body's inverse inertia to get the velocity change.
            Vector3Wide.Scale(basis.X, constraintSpaceImpulse.X, out var linearImpulseAX);
            Vector3Wide.Scale(basis.Z, constraintSpaceImpulse.Y, out var linearImpulseAY);
            Vector3Wide.Add(linearImpulseAX, linearImpulseAY, out var linearImpulseA);
            Vector3Wide.Scale(linearImpulseA, inertiaA.InverseMass, out var linearChangeA);
            Vector3Wide.Add(velocityA.Linear, linearChangeA, out velocityA.Linear);
            Vector3Wide.Scale(linearImpulseA, inertiaB.InverseMass, out var negatedLinearChangeB); //Linear jacobians for B are just A's negated linear jacobians.
            Vector3Wide.Subtract(velocityB.Linear, negatedLinearChangeB, out velocityB.Linear);

            Matrix2x3Wide.Transform(constraintSpaceImpulse, angularJacobianA, out var angularImpulseA);
            Symmetric3x3Wide.TransformWithoutOverlap(angularImpulseA, inertiaA.InverseInertiaTensor, out var angularChangeA);
            Vector3Wide.Add(velocityA.Angular, angularChangeA, out velocityA.Angular);
            Matrix2x3Wide.Transform(constraintSpaceImpulse, angularJacobianB, out var angularImpulseB);
            Symmetric3x3Wide.TransformWithoutOverlap(angularImpulseB, inertiaB.InverseInertiaTensor, out var angularChangeB);
            Vector3Wide.Add(velocityB.Angular, angularChangeB, out velocityB.Angular);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static void ApplyVerticalImpulse(in Matrix3x3Wide basis,
            in Vector3Wide angularJacobianA, in Vector3Wide angularJacobianB, in Vector<float> constraintSpaceImpulse,
            in BodyInertias inertiaA, in BodyInertias inertiaB,
            ref BodyVelocities velocityA, ref BodyVelocities velocityB)
        {
            Vector3Wide.Scale(basis.Y, constraintSpaceImpulse, out var linearImpulseA);
            Vector3Wide.Scale(linearImpulseA, inertiaA.InverseMass, out var linearChangeA);
            Vector3Wide.Add(velocityA.Linear, linearChangeA, out velocityA.Linear);
            Vector3Wide.Scale(linearImpulseA, inertiaB.InverseMass, out var negatedLinearChangeB); //Linear jacobians for B are just A's negated linear jacobians.
            Vector3Wide.Subtract(velocityB.Linear, negatedLinearChangeB, out velocityB.Linear);

            Vector3Wide.Scale(angularJacobianA, constraintSpaceImpulse, out var angularImpulseA);
            Symmetric3x3Wide.TransformWithoutOverlap(angularImpulseA, inertiaA.InverseInertiaTensor, out var angularChangeA);
            Vector3Wide.Add(velocityA.Angular, angularChangeA, out velocityA.Angular);
            Vector3Wide.Scale(angularJacobianB, constraintSpaceImpulse, out var angularImpulseB);
            Symmetric3x3Wide.TransformWithoutOverlap(angularImpulseB, inertiaB.InverseInertiaTensor, out var angularChangeB);
            Vector3Wide.Add(velocityB.Angular, angularChangeB, out velocityB.Angular);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void WarmStart(ref BodyVelocities velocityA, ref BodyVelocities velocityB, ref DynamicCharacterMotionProjection projection, ref CharacterMotionAccumulatedImpulse accumulatedImpulse)
        {
            ComputeJacobians(projection.OffsetFromCharacter, projection.OffsetFromSupport, projection.SurfaceBasis,
                out var basis, out var horizontalAngularJacobianA, out var horizontalAngularJacobianB, out var verticalAngularJacobianA, out var verticalAngularJacobianB);
            ApplyHorizontalImpulse(basis, horizontalAngularJacobianA, horizontalAngularJacobianB, accumulatedImpulse.Horizontal, projection.InertiaA, projection.InertiaB, ref velocityA, ref velocityB);
            ApplyVerticalImpulse(basis, verticalAngularJacobianA, verticalAngularJacobianB, accumulatedImpulse.Vertical, projection.InertiaA, projection.InertiaB, ref velocityA, ref velocityB);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Solve(ref BodyVelocities velocityA, ref BodyVelocities velocityB, ref DynamicCharacterMotionProjection projection, ref CharacterMotionAccumulatedImpulse accumulatedImpulse)
        {
            ComputeJacobians(projection.OffsetFromCharacter, projection.OffsetFromSupport, projection.SurfaceBasis,
                out var basis, out var horizontalAngularJacobianA, out var horizontalAngularJacobianB, out var verticalAngularJacobianA, out var verticalAngularJacobianB);

            //Compute the velocity error by projecting the body velocity into constraint space using the transposed jacobian.
            Vector2Wide horizontalLinearA;
            Vector3Wide.Dot(basis.X, velocityA.Linear, out horizontalLinearA.X);
            Vector3Wide.Dot(basis.Z, velocityA.Linear, out horizontalLinearA.Y);
            Matrix2x3Wide.TransformByTransposeWithoutOverlap(velocityA.Angular, horizontalAngularJacobianA, out var horizontalAngularA);
            Vector2Wide negatedHorizontalLinearB;
            Vector3Wide.Dot(basis.X, velocityB.Linear, out negatedHorizontalLinearB.X);
            Vector3Wide.Dot(basis.Z, velocityB.Linear, out negatedHorizontalLinearB.Y);
            Matrix2x3Wide.TransformByTransposeWithoutOverlap(velocityB.Angular, horizontalAngularJacobianB, out var horizontalAngularB);
            Vector2Wide.Add(horizontalAngularA, horizontalAngularB, out var horizontalAngular);
            Vector2Wide.Subtract(horizontalLinearA, negatedHorizontalLinearB, out var horizontalLinear);
            Vector2Wide.Add(horizontalAngular, horizontalLinear, out var horizontalVelocity);

            Vector2Wide.Subtract(projection.TargetVelocity, horizontalVelocity, out var horizontalConstraintSpaceVelocityChange);
            Symmetric2x2Wide.TransformWithoutOverlap(horizontalConstraintSpaceVelocityChange, projection.HorizontalEffectiveMass, out var horizontalCorrectiveImpulse);

            //Limit the force applied by the horizontal motion constraint. Note that this clamps the *accumulated* impulse applied this time step, not just this one iterations' value.
            var previousHorizontalAccumulatedImpulse = accumulatedImpulse.Horizontal;
            Vector2Wide.Add(accumulatedImpulse.Horizontal, horizontalCorrectiveImpulse, out accumulatedImpulse.Horizontal);
            Vector2Wide.Length(accumulatedImpulse.Horizontal, out var horizontalImpulseMagnitude);
            //Note division by zero guard.
            var scale = Vector.Min(Vector<float>.One, projection.MaximumHorizontalImpulse / Vector.Max(new Vector<float>(1e-16f), horizontalImpulseMagnitude));
            Vector2Wide.Scale(accumulatedImpulse.Horizontal, scale, out accumulatedImpulse.Horizontal);
            Vector2Wide.Subtract(accumulatedImpulse.Horizontal, previousHorizontalAccumulatedImpulse, out horizontalCorrectiveImpulse);

            ApplyHorizontalImpulse(basis, horizontalAngularJacobianA, horizontalAngularJacobianB, horizontalCorrectiveImpulse, projection.InertiaA, projection.InertiaB, ref velocityA, ref velocityB);

            //Same thing for the vertical constraint.
            Vector3Wide.Dot(basis.Y, velocityA.Linear, out var verticalLinearA);
            Vector3Wide.Dot(velocityA.Angular, verticalAngularJacobianA, out var verticalAngularA);
            Vector3Wide.Dot(basis.Y, velocityB.Linear, out var negatedVerticalLinearB);
            Vector3Wide.Dot(velocityB.Angular, verticalAngularJacobianB, out var verticalAngularB);
            //The vertical constraint just targets zero velocity, but does not attempt to fight any velocity which would merely push the character out of penetration.
            var verticalCorrectiveImpulse = (projection.VerticalBiasVelocity - verticalLinearA + negatedVerticalLinearB - verticalAngularA - verticalAngularB) * projection.VerticalEffectiveMass;

            //Clamp the vertical constraint's impulse, but note that this is a bit different than above- the vertical constraint is not allowed to *push*, so there's an extra bound at zero.
            var previousVerticalAccumulatedImpulse = accumulatedImpulse.Vertical;
            accumulatedImpulse.Vertical = Vector.Min(Vector<float>.Zero, Vector.Max(accumulatedImpulse.Vertical + verticalCorrectiveImpulse, -projection.MaximumVerticalForce));
            verticalCorrectiveImpulse = accumulatedImpulse.Vertical - previousVerticalAccumulatedImpulse;

            ApplyVerticalImpulse(basis, verticalAngularJacobianA, verticalAngularJacobianB, verticalCorrectiveImpulse, projection.InertiaA, projection.InertiaB, ref velocityA, ref velocityB);
        }

    }

    //Each constraint type has its own 'type processor'- it acts as the outer loop that handles all the common logic across batches of constraints and invokes
    //the per-constraint logic as needed. The CharacterMotionFunctions type provides the actual implementation.
    public class DynamicCharacterMotionTypeProcessor : TwoBodyTypeProcessor<DynamicCharacterMotionPrestep, DynamicCharacterMotionProjection, CharacterMotionAccumulatedImpulse, DynamicCharacterMotionFunctions>
    {
        /// <summary>
        /// Simulation-wide unique id for the character motion constraint. Every type has needs a unique compile time id; this is a little bit annoying to guarantee given that there is no central
        /// registry of all types that can exist (custom ones, like this one, can always be created), but having it be constant helps simplify and optimize its internal usage.
        /// </summary>
        public const int BatchTypeId = 51;
    }

    /// <summary>
    /// Raw data for a dynamic character controller instance.
    /// </summary>
    public struct CharacterController
    {
        /// <summary>
        /// Direction the character is looking in world space. Defines the forward direction for movement.
        /// </summary>
        public Vector3 ViewDirection;
        /// <summary>
        /// Target horizontal velocity. 
        /// X component refers to desired velocity along the strafing direction (perpendicular to the view direction projected down to the surface), 
        /// Y component refers to the desired velocity along the forward direction (aligned with the view direction projected down to the surface).
        /// </summary>
        public Vector2 TargetVelocity;
        /// <summary>
        /// If true, the character will try to jump on the next time step. Will be reset to false after being processed.
        /// </summary>
        public bool TryJump;

        /// <summary>
        /// Handle of the body associated with the character.
        /// </summary>
        public BodyHandle BodyHandle;
        /// <summary>
        /// Character's up direction in the local space of the character's body.
        /// </summary>
        public Vector3 LocalUp;
        /// <summary>
        /// Velocity at which the character pushes off the support during a jump.
        /// </summary>
        public float JumpVelocity;
        /// <summary>
        /// Maximum force the character can apply tangent to the supporting surface to move.
        /// </summary>
        public float MaximumHorizontalForce;
        /// <summary>
        /// Maximum force the character can apply to glue itself to the supporting surface.
        /// </summary>
        public float MaximumVerticalForce;
        /// <summary>
        /// Cosine of the maximum slope angle that the character can treat as a support.
        /// </summary>
        public float CosMaximumSlope;
        /// <summary>
        /// Depth threshold beyond which a contact is considered a support if it the normal allows it.
        /// </summary>
        public float MinimumSupportDepth;
        /// <summary>
        /// Depth threshold beyond which a contact is considered a support if the previous frame had support, even if it isn't deep enough to meet the MinimumSupportDepth.
        /// </summary>
        public float MinimumSupportContinuationDepth;

        /// <summary>
        /// Whether the character is currently supported.
        /// </summary>
        public bool Supported;
        /// <summary>
        /// Collidable supporting the character, if any. Only valid if Supported is true.
        /// </summary>
        public CollidableReference Support;
        /// <summary>
        /// Handle of the character's motion constraint, if any. Only valid if Supported is true.
        /// </summary>
        public ConstraintHandle MotionConstraintHandle;
    }

    /// <summary>
    /// System that manages all the characters in a simulation. Responsible for updating movement constraints based on character goals and contact states.
    /// </summary>
    public class CharacterControllers : IDisposable
    {
        /// <summary>
        /// Gets the simulation to which this set of chracters belongs.
        /// </summary>
        public BepuPhysics.Simulation Simulation { get; private set; }
        BufferPool pool;

        Buffer<int> bodyHandleToCharacterIndex;
        QuickList<CharacterController> characters;

        /// <summary>
        /// Gets the number of characters being controlled.
        /// </summary>
        public int CharacterCount { get { return characters.Count; } }

        /// <summary>
        /// Creates a character controller systme.
        /// </summary>
        /// <param name="pool">Pool to allocate resources from.</param>
        /// <param name="initialCharacterCapacity">Number of characters to initially allocate space for.</param>
        /// <param name="initialBodyHandleCapacity">Number of body handles to initially allocate space for in the body handle->character mapping.</param>
        public CharacterControllers(BufferPool pool, int initialCharacterCapacity = 4096, int initialBodyHandleCapacity = 4096)
        {
            this.pool = pool;
            characters = new QuickList<CharacterController>(initialCharacterCapacity, pool);
            ResizeBodyHandleCapacity(initialBodyHandleCapacity);
            analyzeContactsWorker = AnalyzeContactsWorker;
            expandBoundingBoxesWorker = ExpandBoundingBoxesWorker;
        }

        /// <summary>
        /// Caches the simulation associated with the characters.
        /// </summary>
        /// <param name="simulation">Simulation to be associated with the characters.</param>
        public void Initialize(BepuPhysics.Simulation simulation)
        {
            Simulation = simulation;
            simulation.Solver.Register<DynamicCharacterMotionConstraint>();
            simulation.Solver.Register<StaticCharacterMotionConstraint>();
            simulation.Timestepper.BeforeCollisionDetection += PrepareForContacts;
            simulation.Timestepper.CollisionsDetected += AnalyzeContacts;
        }

        private void ResizeBodyHandleCapacity(int bodyHandleCapacity)
        {
            var oldCapacity = bodyHandleToCharacterIndex.Length;
            pool.ResizeToAtLeast(ref bodyHandleToCharacterIndex, bodyHandleCapacity, bodyHandleToCharacterIndex.Length);
            if (bodyHandleToCharacterIndex.Length > oldCapacity)
            {
                Unsafe.InitBlockUnaligned(ref Unsafe.As<int, byte>(ref bodyHandleToCharacterIndex[oldCapacity]), 0xFF, (uint)((bodyHandleToCharacterIndex.Length - oldCapacity) * sizeof(int)));
            }
        }

        /// <summary>
        /// Gets the current memory slot index of a character using its associated body handle.
        /// </summary>
        /// <param name="bodyHandle">Body handle associated with the character to look up the index of.</param>
        /// <returns>Index of the character associated with the body handle.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int GetCharacterIndexForBodyHandle(int bodyHandle)
        {
            Debug.Assert(bodyHandle >= 0 && bodyHandle < bodyHandleToCharacterIndex.Length && bodyHandleToCharacterIndex[bodyHandle] >= 0, "Can only look up indices for body handles associated with characters in this CharacterControllers instance.");
            return bodyHandleToCharacterIndex[bodyHandle];
        }

        /// <summary>
        /// Gets a reference to the character at the given memory slot index.
        /// </summary>
        /// <param name="index">Index of the character to retrieve.</param>
        /// <returns>Reference to the character at the given memory slot index.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ref CharacterController GetCharacterByIndex(int index)
        {
            return ref characters[index];
        }

        /// <summary>
        /// Gets a reference to the character using the handle of the character's body.
        /// </summary>
        /// <param name="bodyHandle">Body handle of the character to look up.</param>
        /// <returns>Reference to the character associated with the given body handle.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ref CharacterController GetCharacterByBodyHandle(BodyHandle bodyHandle)
        {
            Debug.Assert(bodyHandle.Value >= 0 && bodyHandle.Value < bodyHandleToCharacterIndex.Length && bodyHandleToCharacterIndex[bodyHandle.Value] >= 0, "Can only look up indices for body handles associated with characters in this CharacterControllers instance.");
            return ref characters[bodyHandleToCharacterIndex[bodyHandle.Value]];
        }

        /// <summary>
        /// Allocates a character.
        /// </summary>
        /// <param name="bodyHandle">Body handle associated with the character.</param>
        /// <returns>Reference to the allocated character.</returns>
        public ref CharacterController AllocateCharacter(BodyHandle bodyHandle)
        {
            Debug.Assert(bodyHandle.Value >= 0 && (bodyHandle.Value >= bodyHandleToCharacterIndex.Length || bodyHandleToCharacterIndex[bodyHandle.Value] == -1),
                "Cannot allocate more than one character for the same body handle.");
            if (bodyHandle.Value >= bodyHandleToCharacterIndex.Length)
                ResizeBodyHandleCapacity(Math.Max(bodyHandle.Value + 1, bodyHandleToCharacterIndex.Length * 2));
            var characterIndex = characters.Count;
            ref var character = ref characters.Allocate(pool);
            character = default;
            character.BodyHandle = bodyHandle;
            bodyHandleToCharacterIndex[bodyHandle.Value] = characterIndex;
            return ref character;
        }

        /// <summary>
        /// Removes a character from the character controllers set by the character's index.
        /// </summary>
        /// <param name="characterIndex">Index of the character to remove.</param>
        public void RemoveCharacterByIndex(int characterIndex)
        {
            Debug.Assert(characterIndex >= 0 && characterIndex < characters.Count, "Character index must exist in the set of characters.");
            ref var character = ref characters[characterIndex];
            Debug.Assert(character.BodyHandle.Value >= 0 && character.BodyHandle.Value < bodyHandleToCharacterIndex.Length && bodyHandleToCharacterIndex[character.BodyHandle.Value] == characterIndex,
                "Character must exist in the set of characters.");
            bodyHandleToCharacterIndex[character.BodyHandle.Value] = -1;
            characters.FastRemoveAt(characterIndex);
            //If the removal moved a character, update the body handle mapping.
            if (characters.Count > characterIndex)
            {
                bodyHandleToCharacterIndex[characters[characterIndex].BodyHandle.Value] = characterIndex;
            }
        }

        /// <summary>
        /// Removes a character from the character controllers set by the body handle associated with the character.
        /// </summary>
        /// <param name="bodyHandle">Body handle associated with the character to remove.</param>
        public void RemoveCharacterByBodyHandle(BodyHandle bodyHandle)
        {
            Debug.Assert(bodyHandle.Value >= 0 && bodyHandle.Value < bodyHandleToCharacterIndex.Length && bodyHandleToCharacterIndex[bodyHandle.Value] >= 0,
                "Removing a character by body handle requires that a character associated with the given body handle actually exists.");
            RemoveCharacterByIndex(bodyHandleToCharacterIndex[bodyHandle.Value]);
        }

        struct SupportCandidate
        {
            public Vector3 OffsetFromCharacter;
            public float Depth;
            public Vector3 OffsetFromSupport;
            public Vector3 Normal;
            public CollidableReference Support;
        }

        struct ContactCollectionWorkerCache
        {
            public Buffer<SupportCandidate> SupportCandidates;

            public unsafe ContactCollectionWorkerCache(int maximumCharacterCount, BufferPool pool)
            {
                pool.Take(maximumCharacterCount, out SupportCandidates);
                for (int i = 0; i < maximumCharacterCount; ++i)
                {
                    //Initialize the depths to a value that guarantees replacement.
                    SupportCandidates[i].Depth = float.MinValue;
                }
            }

            public void Dispose(BufferPool pool)
            {
                pool.Return(ref SupportCandidates);
            }
        }


        Buffer<ContactCollectionWorkerCache> contactCollectionWorkerCaches;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        bool TryReportContacts<TManifold>(CollidableReference characterCollidable, CollidableReference supportCollidable, CollidablePair pair, ref TManifold manifold, int workerIndex) where TManifold : struct, IContactManifold<TManifold>
        {
            if (characterCollidable.Mobility == CollidableMobility.Dynamic && characterCollidable.BodyHandle.Value < bodyHandleToCharacterIndex.Length)
            {
                var characterBodyHandle = characterCollidable.BodyHandle;
                var characterIndex = bodyHandleToCharacterIndex[characterBodyHandle.Value];
                if (characterIndex >= 0)
                {
                    //This is actually a character.
                    ref var character = ref characters[characterIndex];
                    //Our job here is to process the manifold into a support representation. That means a single point, normal, and importance heuristic.
                    //Note that we cannot safely pick from the candidates in this function- it is likely executed from a multithreaded context, so all we can do is
                    //output the pair's result into a worker-exclusive buffer.

                    //Contacts with sufficiently negative depth will not be considered support candidates.
                    //Contacts with intermediate depth (above minimum threshold, but still below negative epsilon) may be candidates if the character previously had support.
                    //Contacts with depth above negative epsilon always pass the depth test.

                    //Maximum depth is used to heuristically choose which contact represents the support.
                    //Note that this could be changed to subtly modify the behavior- for example, dotting the movement direction with the support normal and such.
                    //A more careful choice of heuristic could make the character more responsive when trying to 'step' up obstacles.

                    //Note that the body may be inactive during this callback even though it will be activated by new constraints after the narrow phase flushes.
                    //Have to take into account the current potentially inactive location.
                    ref var bodyLocation = ref Simulation.Bodies.HandleToLocation[character.BodyHandle.Value];
                    ref var set = ref Simulation.Bodies.Sets[bodyLocation.SetIndex];
                    ref var pose = ref set.Poses[bodyLocation.Index];
                    QuaternionEx.Transform(character.LocalUp, pose.Orientation, out var up);
                    //Note that this branch is compiled out- the generic constraints force type specialization.
                    if (manifold.Convex)
                    {
                        ref var convexManifold = ref Unsafe.As<TManifold, ConvexContactManifold>(ref manifold);
                        var normalUpDot = Vector3.Dot(convexManifold.Normal, up);
                        //The narrow phase generates contacts with normals pointing from B to A by convention.
                        //If the character is collidable B, then we need to negate the comparison.
                        if ((pair.B.Packed == characterCollidable.Packed ? -normalUpDot : normalUpDot) > character.CosMaximumSlope)
                        {
                            //This manifold has a slope that is potentially supportive.
                            //Can the maximum depth contact be used as a support?
                            var maximumDepth = convexManifold.Contact0.Depth;
                            var maximumDepthIndex = 0;
                            for (int i = 1; i < convexManifold.Count; ++i)
                            {
                                ref var candidateDepth = ref Unsafe.Add(ref convexManifold.Contact0, i).Depth;
                                if (candidateDepth > maximumDepth)
                                {
                                    maximumDepth = candidateDepth;
                                    maximumDepthIndex = i;
                                }
                            }
                            if (maximumDepth >= character.MinimumSupportDepth || (character.Supported && maximumDepth > character.MinimumSupportContinuationDepth))
                            {
                                ref var supportCandidate = ref contactCollectionWorkerCaches[workerIndex].SupportCandidates[characterIndex];
                                if (supportCandidate.Depth < maximumDepth)
                                {
                                    //This support candidate should be replaced.
                                    supportCandidate.Depth = maximumDepth;
                                    ref var deepestContact = ref Unsafe.Add(ref convexManifold.Contact0, maximumDepthIndex);
                                    var offsetFromB = deepestContact.Offset - convexManifold.OffsetB;
                                    if (pair.B.Packed == characterCollidable.Packed)
                                    {
                                        supportCandidate.Normal = -convexManifold.Normal;
                                        supportCandidate.OffsetFromCharacter = offsetFromB;
                                        supportCandidate.OffsetFromSupport = deepestContact.Offset;
                                    }
                                    else
                                    {
                                        supportCandidate.Normal = convexManifold.Normal;
                                        supportCandidate.OffsetFromCharacter = deepestContact.Offset;
                                        supportCandidate.OffsetFromSupport = offsetFromB;
                                    }
                                    supportCandidate.Support = supportCollidable;
                                }
                            }
                        }
                    }
                    else
                    {
                        ref var nonconvexManifold = ref Unsafe.As<TManifold, NonconvexContactManifold>(ref manifold);
                        //The narrow phase generates contacts with normals pointing from B to A by convention.
                        //If the character is collidable B, then we need to negate the comparison.
                        //This manifold has a slope that is potentially supportive.
                        //Can the maximum depth contact be used as a support?
                        var maximumDepth = float.MinValue;
                        var maximumDepthIndex = -1;
                        for (int i = 0; i < nonconvexManifold.Count; ++i)
                        {
                            ref var candidate = ref Unsafe.Add(ref nonconvexManifold.Contact0, i);
                            if (candidate.Depth > maximumDepth)
                            {
                                //All the nonconvex candidates can have different normals, so we have to perform the (calibrated) normal test on every single one.
                                var upDot = Vector3.Dot(candidate.Normal, up);
                                if ((pair.B.Packed == characterCollidable.Packed ? -upDot : upDot) > character.CosMaximumSlope)
                                {
                                    maximumDepth = candidate.Depth;
                                    maximumDepthIndex = i;
                                }
                            }
                        }
                        if (maximumDepth >= character.MinimumSupportDepth || (character.Supported && maximumDepth > character.MinimumSupportContinuationDepth))
                        {
                            ref var supportCandidate = ref contactCollectionWorkerCaches[workerIndex].SupportCandidates[characterIndex];
                            if (supportCandidate.Depth < maximumDepth)
                            {
                                //This support candidate should be replaced.
                                ref var deepestContact = ref Unsafe.Add(ref nonconvexManifold.Contact0, maximumDepthIndex);
                                supportCandidate.Depth = maximumDepth;
                                var offsetFromB = deepestContact.Offset - nonconvexManifold.OffsetB;
                                if (pair.B.Packed == characterCollidable.Packed)
                                {
                                    supportCandidate.Normal = -deepestContact.Normal;
                                    supportCandidate.OffsetFromCharacter = offsetFromB;
                                    supportCandidate.OffsetFromSupport = deepestContact.Offset;
                                }
                                else
                                {
                                    supportCandidate.Normal = deepestContact.Normal;
                                    supportCandidate.OffsetFromCharacter = deepestContact.Offset;
                                    supportCandidate.OffsetFromSupport = offsetFromB;
                                }
                                supportCandidate.Support = supportCollidable;
                            }
                        }
                    }
                    return true;
                }
            }
            return false;
        }


        /// <summary>
        /// Reports contacts about a collision to the character system. If the pair does not involve a character or there are no contacts, does nothing and returns false.
        /// </summary>
        /// <param name="pair">Pair of objects associated with the contact manifold.</param>
        /// <param name="manifold">Contact manifold between the colliding objects.</param>
        /// <param name="workerIndex">Index of the currently executing worker thread.</param>
        /// <param name="materialProperties">Material properties for this pair. Will be modified if the pair involves a character.</param>
        /// <returns>True if the pair involved a character pair and has contacts, false otherwise.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool TryReportContacts<TManifold>(in CollidablePair pair, ref TManifold manifold, int workerIndex, ref PairMaterialProperties materialProperties) where TManifold : struct, IContactManifold<TManifold>
        {
            Debug.Assert(contactCollectionWorkerCaches.Allocated && workerIndex < contactCollectionWorkerCaches.Length && contactCollectionWorkerCaches[workerIndex].SupportCandidates.Allocated,
                "Worker caches weren't properly allocated; did you forget to call PrepareForContacts before collision detection?");
            if (manifold.Count == 0)
                return false;
            //It's possible for neither, one, or both collidables to be a character. Check each one, treating the other as a potential support.
            var aIsCharacter = TryReportContacts(pair.A, pair.B, pair, ref manifold, workerIndex);
            var bIsCharacter = TryReportContacts(pair.B, pair.A, pair, ref manifold, workerIndex);
            if (aIsCharacter || bIsCharacter)
            {
                //The character's motion over the surface should be controlled entirely by the horizontal motion constraint.
                //Note- you could use the friction coefficient to change the horizontal motion constraint's maximum force to simulate different environments if you want.
                //That would just require caching a bit more information for the AnalyzeContacts function to use.
                materialProperties.FrictionCoefficient = 0;
                return true;
            }
            return false;
        }

        Buffer<(int Start, int Count)> boundingBoxExpansionJobs;
        unsafe void ExpandBoundingBoxes(int start, int count)
        {
            var end = start + count;
            for (int i = start; i < end; ++i)
            {
                ref var character = ref characters[i];
                var characterBody = Simulation.Bodies.GetBodyReference(character.BodyHandle);
                if (characterBody.Awake)
                {
                    Simulation.BroadPhase.GetActiveBoundsPointers(characterBody.Collidable.BroadPhaseIndex, out var min, out var max);
                    QuaternionEx.Transform(character.LocalUp, characterBody.Pose.Orientation, out var characterUp);
                    var supportExpansion = character.MinimumSupportContinuationDepth * characterUp;
                    *min += Vector3.Min(Vector3.Zero, supportExpansion);
                    *max += Vector3.Max(Vector3.Zero, supportExpansion);
                }
            }
        }

        int boundingBoxExpansionJobIndex;
        Action<int> expandBoundingBoxesWorker;
        void ExpandBoundingBoxesWorker(int workerIndex)
        {
            while (true)
            {
                var jobIndex = Interlocked.Increment(ref boundingBoxExpansionJobIndex);
                if (jobIndex < boundingBoxExpansionJobs.Length)
                {
                    ref var job = ref boundingBoxExpansionJobs[jobIndex];
                    ExpandBoundingBoxes(job.Start, job.Count);
                }
                else
                {
                    break;
                }
            }
        }

        /// <summary>
        /// Preallocates space for support data collected during the narrow phase. Should be called before the narrow phase executes.
        /// </summary>
        void PrepareForContacts(float dt, IThreadDispatcher threadDispatcher = null)
        {
            Debug.Assert(!contactCollectionWorkerCaches.Allocated, "Worker caches were already allocated; did you forget to call AnalyzeContacts after collision detection to flush the previous frame's results?");
            var threadCount = threadDispatcher == null ? 1 : threadDispatcher.ThreadCount;
            pool.Take(threadCount, out contactCollectionWorkerCaches);
            for (int i = 0; i < contactCollectionWorkerCaches.Length; ++i)
            {
                contactCollectionWorkerCaches[i] = new ContactCollectionWorkerCache(characters.Count, pool);
            }
            //While the character will retain support with contacts with depths above the MinimumSupportContinuationDepth if there was support in the previous frame,
            //it's possible for the contacts to be lost because the bounding box isn't expanded by MinimumSupportContinuationDepth and the broad phase doesn't see the support collidable.
            //Here, we expand the bounding boxes to compensate.
            if (threadCount == 1 || characters.Count < 256)
            {
                ExpandBoundingBoxes(0, characters.Count);
            }
            else
            {
                var jobCount = Math.Min(characters.Count, threadCount);
                var charactersPerJob = characters.Count / jobCount;
                var baseCharacterCount = charactersPerJob * jobCount;
                var remainder = characters.Count - baseCharacterCount;
                pool.Take(jobCount, out boundingBoxExpansionJobs);
                var previousEnd = 0;
                for (int jobIndex = 0; jobIndex < jobCount; ++jobIndex)
                {
                    var charactersForJob = jobIndex < remainder ? charactersPerJob + 1 : charactersPerJob;
                    ref var job = ref boundingBoxExpansionJobs[jobIndex];
                    job.Start = previousEnd;
                    job.Count = charactersForJob;
                    previousEnd += job.Count;
                }

                boundingBoxExpansionJobIndex = -1;
                threadDispatcher.DispatchWorkers(expandBoundingBoxesWorker);
                pool.Return(ref boundingBoxExpansionJobs);

            }
        }

        struct PendingDynamicConstraint
        {
            public int CharacterIndex;
            public DynamicCharacterMotionConstraint Description;
        }
        struct PendingStaticConstraint
        {
            public int CharacterIndex;
            public StaticCharacterMotionConstraint Description;
        }
        struct Jump
        {
            //Note that not every jump will contain a support body, so this can waste memory.
            //That's not really a concern- jumps are very rare (relatively speaking), so all we're wasting is capacity, not bandwidth.
            public int CharacterBodyIndex;
            public Vector3 CharacterVelocityChange;
            public int SupportBodyIndex;
            public Vector3 SupportImpulseOffset;
        }

        struct AnalyzeContactsWorkerCache
        {
            //The solver does not permit multithreaded removals and additions. We handle all of them in a sequential postpass.
            public QuickList<ConstraintHandle> ConstraintHandlesToRemove;
            public QuickList<PendingDynamicConstraint> DynamicConstraintsToAdd;
            public QuickList<PendingStaticConstraint> StaticConstraintsToAdd;
            public QuickList<Jump> Jumps;

            public AnalyzeContactsWorkerCache(int maximumCharacterCount, BufferPool pool)
            {
                ConstraintHandlesToRemove = new QuickList<ConstraintHandle>(maximumCharacterCount, pool);
                DynamicConstraintsToAdd = new QuickList<PendingDynamicConstraint>(maximumCharacterCount, pool);
                StaticConstraintsToAdd = new QuickList<PendingStaticConstraint>(maximumCharacterCount, pool);
                Jumps = new QuickList<Jump>(maximumCharacterCount, pool);
            }

            public void Dispose(BufferPool pool)
            {
                ConstraintHandlesToRemove.Dispose(pool);
                DynamicConstraintsToAdd.Dispose(pool);
                StaticConstraintsToAdd.Dispose(pool);
                Jumps.Dispose(pool);
            }
        }

        Buffer<AnalyzeContactsWorkerCache> analyzeContactsWorkerCaches;

        void AnalyzeContactsForCharacterRegion(int start, int exclusiveEnd, int workerIndex)
        {
            ref var analyzeContactsWorkerCache = ref analyzeContactsWorkerCaches[workerIndex];
            for (int characterIndex = start; characterIndex < exclusiveEnd; ++characterIndex)
            {
                //Note that this iterates over both active and inactive characters rather than segmenting inactive characters into their own collection.
                //This demands branching, but the expectation is that the vast majority of characters will be active, so there is less value in copying them into stasis.                
                ref var character = ref characters[characterIndex];
                ref var bodyLocation = ref Simulation.Bodies.HandleToLocation[character.BodyHandle.Value];
                if (bodyLocation.SetIndex == 0)
                {
                    var supportCandidate = contactCollectionWorkerCaches[0].SupportCandidates[characterIndex];
                    for (int j = 1; j < contactCollectionWorkerCaches.Length; ++j)
                    {
                        ref var workerCandidate = ref contactCollectionWorkerCaches[j].SupportCandidates[characterIndex];
                        if (workerCandidate.Depth > supportCandidate.Depth)
                        {
                            supportCandidate = workerCandidate;
                        }
                    }
                    //We need to protect against one possible corner case: if the body supporting the character was removed, the associated motion constraint was also removed.
                    //Arbitrarily un-support the character if we detect this.      
                    if (character.Supported)
                    {
                        //If the constraint no longer exists at all, 
                        if (!Simulation.Solver.ConstraintExists(character.MotionConstraintHandle) ||
                            //or if the constraint does exist but is now used by a different constraint type,
                            (Simulation.Solver.HandleToConstraint[character.MotionConstraintHandle.Value].TypeId != DynamicCharacterMotionTypeProcessor.BatchTypeId &&
                            Simulation.Solver.HandleToConstraint[character.MotionConstraintHandle.Value].TypeId != StaticCharacterMotionTypeProcessor.BatchTypeId))
                        {
                            //then the character isn't actually supported anymore.
                            character.Supported = false;
                        }
                        //Note that it's sufficient to only check that the type matches the dynamic motion constraint type id because no other systems ever create dynamic character motion constraints.
                        //Other systems may result in the constraint's removal, but no other system will ever *create* it.
                        //Further, during this analysis loop, we do not create any constraints. We only set up pending additions to be processed after the multithreaded analysis completes.
                    }

                    //The body is active. We may need to remove the associated constraint from the solver. Remove if any of the following hold:
                    //1) The character was previously supported but is no longer.
                    //2) The character was previously supported by a body, and is now supported by a different body.
                    //3) The character was previously supported by a static, and is now supported by a body.
                    //4) The character was previously supported by a body, and is now supported by a static.
                    var shouldRemove = character.Supported && (character.TryJump || supportCandidate.Depth == float.MinValue || character.Support.Packed != supportCandidate.Support.Packed);
                    if (shouldRemove)
                    {
                        //Mark the constraint for removal.
                        analyzeContactsWorkerCache.ConstraintHandlesToRemove.AllocateUnsafely() = character.MotionConstraintHandle;
                    }

                    //If the character is jumping, don't create a constraint.
                    if (supportCandidate.Depth > float.MinValue && character.TryJump)
                    {
                        QuaternionEx.Transform(character.LocalUp, Simulation.Bodies.ActiveSet.Poses[bodyLocation.Index].Orientation, out var characterUp);
                        //Note that we assume that character orientations are constant. This isn't necessarily the case in all uses, but it's a decent approximation.
                        var characterUpVelocity = Vector3.Dot(Simulation.Bodies.ActiveSet.Velocities[bodyLocation.Index].Linear, characterUp);
                        //We don't want the character to be able to 'superboost' by simply adding jump speed on top of horizontal motion.
                        //Instead, jumping targets a velocity change necessary to reach character.JumpVelocity along the up axis.
                        if (character.Support.Mobility != CollidableMobility.Static)
                        {
                            ref var supportingBodyLocation = ref Simulation.Bodies.HandleToLocation[character.Support.BodyHandle.Value];
                            Debug.Assert(supportingBodyLocation.SetIndex == 0, "If the character is active, any support should be too.");
                            ref var supportVelocity = ref Simulation.Bodies.ActiveSet.Velocities[supportingBodyLocation.Index];
                            var wxr = Vector3.Cross(supportVelocity.Angular, supportCandidate.OffsetFromSupport);
                            var supportContactVelocity = supportVelocity.Linear + wxr;
                            var supportUpVelocity = Vector3.Dot(supportContactVelocity, characterUp);

                            //If the support is dynamic, apply an opposing impulse. Note that velocity changes cannot safely be applied during multithreaded execution;
                            //characters could share support bodies, and a character might be a support of another character.
                            //That's really not concerning from a performance perspective- characters don't jump many times per frame.
                            ref var jump = ref analyzeContactsWorkerCache.Jumps.AllocateUnsafely();
                            jump.CharacterBodyIndex = bodyLocation.Index;
                            jump.CharacterVelocityChange = characterUp * MathF.Max(0, character.JumpVelocity - (characterUpVelocity - supportUpVelocity));
                            if (character.Support.Mobility == CollidableMobility.Dynamic)
                            {
                                jump.SupportBodyIndex = supportingBodyLocation.Index;
                                jump.SupportImpulseOffset = supportCandidate.OffsetFromSupport;
                            }
                            else
                            {
                                //No point in applying impulses to kinematics.
                                jump.SupportBodyIndex = -1;
                            }
                        }
                        else
                        {
                            //Static bodies have no velocity, so we don't have to consider the support.
                            ref var jump = ref analyzeContactsWorkerCache.Jumps.AllocateUnsafely();
                            jump.CharacterBodyIndex = bodyLocation.Index;
                            jump.CharacterVelocityChange = characterUp * MathF.Max(0, character.JumpVelocity - characterUpVelocity);
                            jump.SupportBodyIndex = -1;
                        }
                        character.Supported = false;
                    }
                    else if (supportCandidate.Depth > float.MinValue)
                    {
                        //If a support currently exists and there is still an old constraint, then update it.
                        //If a support currently exists and there is not an old constraint, add the new constraint.

                        //Project the view direction down onto the surface as represented by the contact normal.
                        Matrix3x3 surfaceBasis;
                        surfaceBasis.Y = supportCandidate.Normal;
                        //Note negation: we're using a right handed basis where -Z is forward, +Z is backward.
                        QuaternionEx.Transform(character.LocalUp, Simulation.Bodies.ActiveSet.Poses[bodyLocation.Index].Orientation, out var up);
                        var rayDistance = Vector3.Dot(character.ViewDirection, surfaceBasis.Y);
                        var rayVelocity = Vector3.Dot(up, surfaceBasis.Y);
                        Debug.Assert(rayVelocity > 0,
                            "The calibrated support normal and the character's up direction should have a positive dot product if the maximum slope is working properly. Is the maximum slope >= pi/2?");
                        surfaceBasis.Z = up * (rayDistance / rayVelocity) - character.ViewDirection;
                        var zLengthSquared = surfaceBasis.Z.LengthSquared();
                        if (zLengthSquared > 1e-12f)
                        {
                            surfaceBasis.Z /= MathF.Sqrt(zLengthSquared);
                        }
                        else
                        {
                            QuaternionEx.GetQuaternionBetweenNormalizedVectors(Vector3.UnitY, surfaceBasis.Y, out var rotation);
                            QuaternionEx.TransformUnitZ(rotation, out surfaceBasis.Z);
                        }
                        surfaceBasis.X = Vector3.Cross(surfaceBasis.Y, surfaceBasis.Z);
                        QuaternionEx.CreateFromRotationMatrix(surfaceBasis, out var surfaceBasisQuaternion);
                        if (supportCandidate.Support.Mobility != CollidableMobility.Static)
                        {
                            //The character is supported by a body.
                            var motionConstraint = new DynamicCharacterMotionConstraint
                            {
                                MaximumHorizontalForce = character.MaximumHorizontalForce,
                                MaximumVerticalForce = character.MaximumVerticalForce,
                                OffsetFromCharacterToSupportPoint = supportCandidate.OffsetFromCharacter,
                                OffsetFromSupportToSupportPoint = supportCandidate.OffsetFromSupport,
                                SurfaceBasis = surfaceBasisQuaternion,
                                TargetVelocity = character.TargetVelocity,
                                Depth = supportCandidate.Depth
                            };
                            if (character.Supported && !shouldRemove)
                            {
                                //Already exists, update it.
                                Simulation.Solver.ApplyDescriptionWithoutWaking(character.MotionConstraintHandle, ref motionConstraint);
                            }
                            else
                            {
                                //Doesn't exist, mark it for addition.
                                ref var pendingConstraint = ref analyzeContactsWorkerCache.DynamicConstraintsToAdd.AllocateUnsafely();
                                pendingConstraint.Description = motionConstraint;
                                pendingConstraint.CharacterIndex = characterIndex;
                            }
                        }
                        else
                        {
                            //The character is supported by a static.
                            var motionConstraint = new StaticCharacterMotionConstraint
                            {
                                MaximumHorizontalForce = character.MaximumHorizontalForce,
                                MaximumVerticalForce = character.MaximumVerticalForce,
                                OffsetFromCharacterToSupportPoint = supportCandidate.OffsetFromCharacter,
                                SurfaceBasis = surfaceBasisQuaternion,
                                TargetVelocity = character.TargetVelocity,
                                Depth = supportCandidate.Depth
                            };
                            if (character.Supported && !shouldRemove)
                            {
                                //Already exists, update it.
                                Simulation.Solver.ApplyDescriptionWithoutWaking(character.MotionConstraintHandle, ref motionConstraint);
                            }
                            else
                            {
                                //Doesn't exist, mark it for addition.
                                ref var pendingConstraint = ref analyzeContactsWorkerCache.StaticConstraintsToAdd.AllocateUnsafely();
                                pendingConstraint.Description = motionConstraint;
                                pendingConstraint.CharacterIndex = characterIndex;
                            }
                        }
                        character.Supported = true;
                        character.Support = supportCandidate.Support;
                    }
                    else
                    {
                        character.Supported = false;
                    }
                }
                //The TryJump flag is always reset even if the attempt failed.
                character.TryJump = false;
            }
        }

        struct AnalyzeContactsJob
        {
            public int Start;
            public int ExclusiveEnd;
        }

        int analysisJobIndex;
        int analysisJobCount;
        Buffer<AnalyzeContactsJob> jobs;
        Action<int> analyzeContactsWorker;
        void AnalyzeContactsWorker(int workerIndex)
        {
            int jobIndex;
            while ((jobIndex = Interlocked.Increment(ref analysisJobIndex)) < analysisJobCount)
            {
                ref var job = ref jobs[jobIndex];
                AnalyzeContactsForCharacterRegion(job.Start, job.ExclusiveEnd, workerIndex);
            }
        }


        /// <summary>
        /// Updates all character support states and motion constraints based on the current character goals and all the contacts collected since the last call to AnalyzeContacts. 
        /// Attach to a simulation callback where the most recent contact is available and before the solver executes.
        /// </summary>
        void AnalyzeContacts(float dt, IThreadDispatcher threadDispatcher)
        {
            //var start = Stopwatch.GetTimestamp();
            Debug.Assert(contactCollectionWorkerCaches.Allocated, "Worker caches weren't properly allocated; did you forget to call PrepareForContacts before collision detection?");

            if (threadDispatcher == null)
            {
                pool.Take(1, out analyzeContactsWorkerCaches);
                analyzeContactsWorkerCaches[0] = new AnalyzeContactsWorkerCache(characters.Count, pool);
                AnalyzeContactsForCharacterRegion(0, characters.Count, 0);
            }
            else
            {
                analysisJobCount = Math.Min(characters.Count, threadDispatcher.ThreadCount * 4);
                if (analysisJobCount > 0)
                {
                    pool.Take(threadDispatcher.ThreadCount, out analyzeContactsWorkerCaches);
                    pool.Take(analysisJobCount, out jobs);
                    for (int i = 0; i < threadDispatcher.ThreadCount; ++i)
                    {
                        analyzeContactsWorkerCaches[i] = new AnalyzeContactsWorkerCache(characters.Count, pool);
                    }
                    var baseCount = characters.Count / analysisJobCount;
                    var remainder = characters.Count - baseCount * analysisJobCount;
                    var previousEnd = 0;
                    for (int i = 0; i < analysisJobCount; ++i)
                    {
                        ref var job = ref jobs[i];
                        job.Start = previousEnd;
                        job.ExclusiveEnd = job.Start + (i < remainder ? baseCount + 1 : baseCount);
                        previousEnd = job.ExclusiveEnd;
                    }
                    analysisJobIndex = -1;
                    threadDispatcher.DispatchWorkers(analyzeContactsWorker);
                    pool.Return(ref jobs);
                }
            }
            //We're done with all the contact collection worker caches.
            for (int i = 0; i < contactCollectionWorkerCaches.Length; ++i)
            {
                contactCollectionWorkerCaches[i].Dispose(pool);
            }
            pool.Return(ref contactCollectionWorkerCaches);

            if (analyzeContactsWorkerCaches.Allocated)
            {
                //Flush all the worker caches. Note that we perform all removals before moving onto any additions to avoid unnecessary constraint batches
                //caused by the new and old constraint affecting the same bodies.
                for (int threadIndex = 0; threadIndex < analyzeContactsWorkerCaches.Length; ++threadIndex)
                {
                    ref var cache = ref analyzeContactsWorkerCaches[threadIndex];
                    for (int i = 0; i < cache.ConstraintHandlesToRemove.Count; ++i)
                    {
                        Simulation.Solver.Remove(cache.ConstraintHandlesToRemove[i]);
                    }
                }
                for (int threadIndex = 0; threadIndex < analyzeContactsWorkerCaches.Length; ++threadIndex)
                {
                    ref var workerCache = ref analyzeContactsWorkerCaches[threadIndex];
                    for (int i = 0; i < workerCache.StaticConstraintsToAdd.Count; ++i)
                    {
                        ref var pendingConstraint = ref workerCache.StaticConstraintsToAdd[i];
                        ref var character = ref characters[pendingConstraint.CharacterIndex];
                        Debug.Assert(character.Support.Mobility == CollidableMobility.Static);
                        character.MotionConstraintHandle = Simulation.Solver.Add(character.BodyHandle, ref pendingConstraint.Description);
                    }
                    for (int i = 0; i < workerCache.DynamicConstraintsToAdd.Count; ++i)
                    {
                        ref var pendingConstraint = ref workerCache.DynamicConstraintsToAdd[i];
                        ref var character = ref characters[pendingConstraint.CharacterIndex];
                        Debug.Assert(character.Support.Mobility != CollidableMobility.Static);
                        character.MotionConstraintHandle = Simulation.Solver.Add(character.BodyHandle, character.Support.BodyHandle, ref pendingConstraint.Description);
                    }
                    ref var activeSet = ref Simulation.Bodies.ActiveSet;
                    for (int i = 0; i < workerCache.Jumps.Count; ++i)
                    {
                        ref var jump = ref workerCache.Jumps[i];
                        activeSet.Velocities[jump.CharacterBodyIndex].Linear += jump.CharacterVelocityChange;
                        if (jump.SupportBodyIndex >= 0)
                        {
                            BodyReference.ApplyImpulse(Simulation.Bodies.ActiveSet, jump.SupportBodyIndex, jump.CharacterVelocityChange / -activeSet.LocalInertias[jump.CharacterBodyIndex].InverseMass, jump.SupportImpulseOffset);
                        }
                    }
                    workerCache.Dispose(pool);
                }
                pool.Return(ref analyzeContactsWorkerCaches);
            }

            //var end = Stopwatch.GetTimestamp();
            //Console.WriteLine($"Time (ms): {(end - start) / (1e-3 * Stopwatch.Frequency)}");
        }

        /// <summary>
        /// Ensures that the internal structures of the character controllers system can handle the given number of characters and body handles, resizing if necessary.
        /// </summary>
        /// <param name="characterCapacity">Minimum character capacity to require.</param>
        /// <param name="bodyHandleCapacity">Minimum number of body handles to allocate space for.</param>
        public void EnsureCapacity(int characterCapacity, int bodyHandleCapacity)
        {
            characters.EnsureCapacity(characterCapacity, pool);
            if (bodyHandleToCharacterIndex.Length < bodyHandleCapacity)
            {
                ResizeBodyHandleCapacity(bodyHandleCapacity);
            }
        }

        /// <summary>
        /// Resizes the internal structures of the character controllers system for the target sizes. Will not shrink below the currently active data size.
        /// </summary>
        /// <param name="characterCapacity">Target character capacity to allocate space for.</param>
        /// <param name="bodyHandleCapacity">Target number of body handles to allocate space for.</param>
        public void Resize(int characterCapacity, int bodyHandleCapacity)
        {
            int lastOccupiedIndex = -1;
            for (int i = bodyHandleToCharacterIndex.Length - 1; i >= 0; --i)
            {
                if (bodyHandleToCharacterIndex[i] != -1)
                {
                    lastOccupiedIndex = i;
                    break;
                }
            }
            var targetHandleCapacity = BufferPool.GetCapacityForCount<int>(Math.Max(lastOccupiedIndex + 1, bodyHandleCapacity));
            if (targetHandleCapacity != bodyHandleToCharacterIndex.Length)
                ResizeBodyHandleCapacity(targetHandleCapacity);

            var targetCharacterCapacity = BufferPool.GetCapacityForCount<int>(Math.Max(characters.Count, characterCapacity));
            if (targetCharacterCapacity != characters.Span.Length)
                characters.Resize(targetCharacterCapacity, pool);
        }

        bool disposed;
        /// <summary>
        /// Returns pool-allocated resources.
        /// </summary>
        public void Dispose()
        {
            if (!disposed)
            {
                disposed = true;
                Simulation.Timestepper.BeforeCollisionDetection -= PrepareForContacts;
                Simulation.Timestepper.CollisionsDetected -= AnalyzeContacts;
                characters.Dispose(pool);
                pool.Return(ref bodyHandleToCharacterIndex);
            }
        }
    }
}
